import pymysql.cursors
import datetime,time
import logging 
import re
logging.basicConfig(filename='test.log', format='%(asctime)s %(message)s',level=logging.DEBUG)
connection = pymysql.connect(host='localhost',
				user='root',
				password='54321',
				db='mydata',
				charset='utf8mb4',
				cursorclass=pymysql.cursors.DictCursor)
def check_real_report(sleep_time = 60):
	with connection.cursor() as cursor:
		curtime = datetime.datetime.now()
		curday = datetime.date.today()
		logging.info('本次检查的当前时间:'+str(curtime))
		delta = datetime.timedelta(minutes=5)
		earliest_time = curtime - delta 
		logging.info('本次检查涵盖的最早时间：'+str(earliest_time))
		sql = "SELECT * FROM `moniter_m_d_real` WHERE `timestamp_v` > %s\
		AND `timestamp_v` < %s"
		cursor.execute(sql, (earliest_time,curtime))
		results = cursor.fetchall()
		if len(results) == 0:
			logging.info('未发现可供检查的数据')
		else:
			logging.info('发现带检查记录'+ str(len(results))+'条')
		for result in results:
			logging.info("监控值m_value:"+str(result['m_value']))
			sql = "SELECT * FROM moniter_m_project_checklist WHERE project_nick = %s AND host_nick = %s AND db_nick = %s AND m_type = %s AND m_status = 'on'"
			cursor.execute(sql, (str(result['project_nick']),str(result['host_nick']),str(result['db_nick']),str(result['m_type'])))
			logging.info("正在监控的数据是：")
			for k,v in result.items():
				logging.info(k + str(v))
			result_check = cursor.fetchone()
			if result_check is None:
				logging.info("未匹配到任何监控项")
				continue
			#检查到该监控阀值为首次调用(Next_checktime==None)，则初始化其Next_checktime值为当前时间
			if result_check['Next_checktime'] is None:
				result_check['Next_checktime'] = curtime
			#根据监控阀值时间类型，选择阀值时间判定分支
			m_interval_time_type_dict = {'everyday':m_interval_time_type_everyday,'period':m_interval_time_period}
			if m_interval_time_type_dict.get(result_check['m_interval_time_type'])(result['timestamp_v'],result_check['Next_checktime'],curtime)[0] is None:
				logging.info('不满足监控阀值的时间要求，该条监控数据被忽略')
				continue
			#返回更新后的该条监控阀值的下次时间
			Next_checktime = m_interval_time_type_dict.get(result_check['m_interval_time_type'])(result['timestamp_v'],result_check['Next_checktime'],curtime)[1]
			#根据监控阀值数值判定类型，选择运算分支	
			m_value_type_dict = {'大于':m_value_type_g,'小于':m_value_type_l,'大于等于':m_value_type_ge,'小于等于':m_value_le,'区间':m_value_interval}
			m_status = m_value_type_dict.get(result_check['m_value_type'])(result,result_check)
			m_interval_time = datetime.timedelta(second=result_check['m_interval_time'])
			#调用告警发送,返回发送状态
			m_send_status = "未发送"
			m_status = m_value_type_dict.get(result_check['m_value_type'])(result,result_check)
			#调用告警发送,返回发送状态
			if m_status == 'error':
				logging.info("需要发送告警信息")
				pass
			else:
				pass 	
			m_send_status = "未发送"
			for k,v in result.items():
				logging.info(k + str(v))
			sql = "INSERT INTO moniter_m_report (project_nick,host_nick,db_nick,m_date,m_timestamp,m_type,m_dim,m_value,m_status,m_send_status,description,timestamp_v)	VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"
			cursor.execute(sql, (result['project_nick'],\
				result['host_nick'],result['db_nick'],curday,result['m_timestamp'],result['m_type'],result['m_dim'],result['m_value'],m_status,m_send_status,result['m_logger'],curtime)
				)
			connection.commit()
			logging.info('监控报告生成')
			#更新数据库中监控阀值的下次告警时间
			if Next_checktime == result_check['Next_checktime']:
				pass
			else:
				sql = "UPDATA SET Next_checktime = %s WHERE id = result_check['id']"
				cursor.execute(sql,Next_checktime))
				connection.commit()			


#m_value_type=='大于'		
def m_value_type_g(result,result_check):
	m_status = int(result['m_value']) > int(result_check['m_value'])?'success':'error'
	return m_status

#m_value_type=='小于'
def m_value_type_l(result,result_check):
	m_status = int(result['m_value']) < int(result_check['m_value'])?'success':'error'
	return m_status

#m_value_type=='大于等于'
def m_value_type_ge(result,result_check):
	m_status = int(result['m_value']) >= int(result_check['m_value'])?'success':'error'
	return m_status

#m_value_type=='小于等于'
def m_value_type_le(result,result_check):
	m_status = int(result['m_value']) <= int(result_check['m_value'])?'success':'error'
	return m_status
#m_value_type=='区间'
def m_value_type_interval(result,result_check):
	value_type = re.match(r'(\d+)(,)(\d+)',str(result_check['m_value']))
	min_value = int(value_type.group(1))
	max_value = int(value_type.group(3))	
	m_status = (min_value <= int(result['m_value'] and int(result['m_value'] <= max_value)?'success':'error'

					
while True:
	check_real_report()
	logging.info('进入休眠')
	time.sleep(30)
